### PHP三大经典设计模式

#### 什么是设计模式
设计模式，是一种解决问题的思维，而并非某种特定的方法。是前人给我们总结的宝贵经验。学习设计模式是为了编写可复用、可拓展、高性能软件。学习设计模式关键是要理解，理解方法，理解思想和观念。设计模式是熟练运用OOP后自然而然形成的代码习惯。达到最高境后只有一句话：高内聚、低耦合。

#### 一、单例模式

##### 单例模式的含义:
作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统全局地提供这个实例。它不会创建实例副本，而是会向单例类内部存储的实例返回一个引用。

##### 单例模式的三个要素:
1.保存类唯一实例的静态变量。
2.构造函数和克隆函数必须是私有的，放在外部去实例化，这样就不存在单例模式的意义。
3.提供一个可供外部访问的公共方法，这个方法返回该类的唯一实例。

##### 单例模式的意义:
在PHP中的应用主要在于数据库应用, 所以一个应用中会存在大量的数据库操作, 在使用面向对象的方式开发时, 如果使用单例模式, 则可以避免大量的new操作消耗的资源。而不完全是对系统资源的节省, 可以避免重复实例化，因为PHP每次实例化一个类之后都会清理掉对应的资源，当再次使用的时候又会在重新去实例化一次。

##### 单例模式使用的场景:
1.数据库操作，减少对数据路的new操作，从而减少内存资源和系统资源的消耗。
2.配置资源的共享，在一个系统中，配置资源都是全局的，使用单例模式也可以减少每次去读取配置带来的内存和系统资源的消耗。

##### 代码演示:
```php
<?php

/**
 * 单例模式
 */
class Db {
    //该静态属性用于存储该类唯一实例
    private static $_instance = null;

    /**
     * 防止使用 new 创建多个实例
     */
    private function __construct(){

    }

    /**
     * 防止 clone 多个实例
     */
    public function __clone(){

    }

    /**
     * 防止反序列化
     */
    private function __wakeup(){
    }

    public static function getInstance(){
        if(!(self::$_instance instanceof self)) {
            self::$_instance = new self();
        }
        return self::$_instance;
    }
}
$db1 = Db::getInstance();
$db2 = Db::getInstance();
var_dump($db1);
var_dump($db2);

// object(Db)#1 (0) { } object(Db)#1 (0) { }  句柄一样
```

#### 二、工厂模式

##### 工厂模式的含义：
负责生成其他对象的方法。简单的描述就是通过一个工厂类，去实例化其他类或者方法。

##### 工厂模式的意义：
通过使用工厂模式，减少因为多处new同一个类，当这个类发生变法时，则需要多处修改。

##### 代码演示：
```php
<?php

/**
 * 工厂模式
 */
class Factory {
    public static function createDb(){
        echo '统一生产一个Db实例'. PHP_EOL;
        return new Db();
    }
}
$db = Factory::createDb();
```

#### 三、注册树模式

##### 注册数的含义:
注册树就是将多个对象注册在一个对象池中，当我们需要使用时，直接从对象池获取即可。

##### 注册数模式的优点：
单例模式解决的是如何在整个项目中创建唯一对象实例的问题，工厂模式解决的是如何不通过new建立实例对象的方法。那么注册树模式想解决什么问题呢？在考虑这个问题前，我们还是有必要考虑下前两种模式目前面临的局限。首先，单例模式创建唯一对象的过程本身还有一种判断，即判断对象是否存在。存在则返回对象，不存在则创建对象并返回。每次创建实例对象都要存在这么一层判断。工厂模式更多考虑的是扩展维护的问题。总的来说，单例模式和工厂模式可以产生更加合理的对象。怎么方便调用这些对象呢？而且在项目内如此建立的对象好像散兵游勇一样，不便统筹管理安排啊。因而，注册树模式应运而生。不管你是通过单例模式还是工厂模式还是二者结合生成的对象，都统统给我“插到”注册树上。我用某个对象的时候，直接从注册树上取一下就好。这和我们使用全局变量一样的方便实用。而且注册树模式还为其他模式提供了一种非常好的想法。

##### 代码演示:
```php
/**
 * 注册树模式
 */
class Register
{
    // 用一个数组来当做对象池，键当做对象别名，值存储具体对象
    public static $objTree = [];

    // 将对象放在对象池
    public static function set($key, $val)
    {
        return self::$objTree[$key] = $val;
    }

    // 通过对象别名在对象池中获取到对象别名
    public static function get($key)
    {
        return self::$objTree[$key];
    }

    // 通过对象别名将对象从对象池中注销
    public static function _unset($key)
    {
        unset(self::$objTree[$key]);
    }
}

Register::set('db', Factory::createDb());
$db = Register::get('db');
var_dump($db);
// 输出：object(Db)#1 (0) { }
```

#### 小结：
- 工厂模式：工厂方法或者类生成对象，而不是在代码中直接new
- 单例模式：使某个类的对象仅允许创建一个
- 注册模式：全局共享和交换对象
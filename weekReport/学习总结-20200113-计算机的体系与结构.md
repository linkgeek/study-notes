## 计算机的体系与结构

#### 冯诺依曼体系

冯诺依曼体系，用一句话来概括就是：将程序指令和数据一起存储的计算机设计概念结构。

通过对计算机的发展历史的了解，我们知道，早期的计算机只能运行固定用途的程序，怎么理解？举个例子：有个计算机它只能运行数学运算的程序，那么它就不能运行文字处理的软件，也不能拿来玩游戏，如果要让它能够进行别的功能，就需要改变计算机的程序，而在当时，所谓的重写程序并不是指现在的重新编译一个程序那么简单，而是必须更改电路或者说更改结构，甚至重新设计这个机器。

这样就很坑爹了啊。如果说计算机只能用来打游戏，不能用来写代码，或者说只能用来写代码，不能用来玩游戏，那么我们就不能先玩一会游戏再写一会代码了，这样子是非常不合理的。于是冯诺依曼就想着将程序存储起来，然后在设计底层硬件的时候，不再是设计专有的电路，而是设计一个通用电路，当我们需要运行某种程序的时候，我们先把这段程序翻译成电路能够理解的语言，然后让通用电路去执行相关的逻辑。

这就是冯诺依曼体系的核心概念——存储程序指令，设计通用电路。

![img](https://img-blog.csdnimg.cn/2019092110405423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215c3RlcnlmbG93ZXI=,size_16,color_FFFFFF,t_70)

了解了冯诺依曼体系是怎样诞生的，如果能够理解冯诺依曼体系给计算机领域带来的巨大改变，我们就能明白冯诺依曼体系为什么这么重要了。由冯诺依曼体系所延伸的存储型计算机的概念，改变了之前糟糕的一切，皆由创造一种通用的指令集结构，并将所谓的运算转化为一串程序指令的运行，使整个计算机更有弹性。借助将指令当成一种特殊类型的计算数据，一台存储型的计算机可以轻易地改变其程序，并且在程序的控制下，改变运行的内容，改变的时候不需要重新设计电路，不需要重新改变计算机的结构，这就是冯诺依曼体系所带来的巨大贡献。

根据冯诺依曼体系结构构成的计算机，必须具有如下功能：

- 把需要的程序和数据送至计算机中。

- 必须具有长期记忆程序、数据、中间结果及最终运算结果的能力。

- 能够完成各种算术、逻辑运算和数据传送等数据加工处理的能力。

- 能够根据需要来控制程序走向，并能根据指令来控制机器的各部件协调操作。

- 能够按照要求将处理结果输出给用户。

  

为了完成上述功能，计算机必须具备五大基本组成部件，包括：

1. 存储器：用来存放程序和数据
2. 控制器：用来控制程序的流转和数据的输入运行，以及处理运算结果
3. 运算器：主要运行算数运算和逻辑运算，并将中间结果暂存到运算器中
4. 输入设备：用来将人们熟悉的信息形式转换为机器能够识别的信息形式，常见的有键盘，鼠标等
5. 输出设备：可以将机器运算结果转换为人们熟悉的信息形式，如打印机输出，显示器输出等



冯诺依曼体系结构示意图：

![img](https://img-blog.csdnimg.cn/20190921104114835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215c3RlcnlmbG93ZXI=,size_16,color_FFFFFF,t_70)

我们可以看到，存储器和CPU是分开的，这就导致一个问题：**CPU和存储器速率之间的问题无法调和**。因为CPU是高速运算的，处理速率极快，而存储器没有CPU快，到CPU的数据传输速度慢，这会导致**CPU经常空转等待数据传输**，这样子是非常浪费资源的。那么，如何解决呢？

#### 现代计算机的结构

- 现代计算机在冯诺依曼体系结构基础上进行了修改
- 解决了CPU和存储设备之间的性能差异问题

下面是现代计算机的结构示意图：

![img](https://img-blog.csdnimg.cn/20190921104153635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L215c3RlcnlmbG93ZXI=,size_16,color_FFFFFF,t_70)

可以看到，跟前面不一样的是，运算器、控制器和存储器组成了现代计算机的CPU。

存储器，从广义上，可以理解为存储数据的介质，包括磁带和硬盘。但是，这里的存储器主要是指围绕CPU的高速设备，包括寄存器和内存。现代计算机的结构，可以理解为以存储器为核心的结构。

![img](http://pre.jiatengfei.com/uploads/article/20200113/5e1c3e637e504.png)

### CPU简介

中央处理器（CPU），是电子计算机的主要设备之一，电脑中的核心配件。其功能主要是解释计算机指令以及处理计算机软件中的数据。CPU是计算机中负责读取指令，对指令译码并执行指令的核心部件。中央处理器主要包括两个部分，即**控制器**、**运算器**，其中还包括**高速缓冲存储器**及实现它们之间联系的数据、控制的总线。电子计算机三大核心部件就是CPU、内部存储器、输入/输出设备。中央处理器的功效主要为处理指令、执行操作、控制时间、处理数据。

在计算机体系结构中，CPU 是对计算机的所有硬件资源（如存储器、输入输出单元） 进行控制调配、执行通用运算的核心硬件单元。CPU 是计算机的运算和控制核心。计算机系统中所有软件层的操作，最终都将通过指令集映射为CPU的操作。

### 工作原理

**冯诺依曼**体系结构是现代计算机的基础。在该体系结构下，程序和数据统一存储，指令和数据需要从同一存储空间存取，经由同一总线传输，无法重叠执行。根据冯诺依曼体系，CPU的工作分为以下 5 个阶段：取指令阶段、指令译码阶段、执行指令阶段、访存取数和结果写回。

取指令（IF，instruction fetch），即将一条指令从**主存储器**中取到**指令寄存器**的过程。程序计数器中的数值，用来指示当前指令在主存中的位置。当 一条指令被取出后，PC中的数值将根据指令字长度自动递增。

指令译码阶段（ID，instruction decode），取出指令后，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类 别以及各种获取操作数的方法。

执行指令阶段（EX，execute），具体实现指令的功能。CPU的不同部分被连接起来，以执行所需的操作。

访存取数阶段（MEM，memory），根据指令需要访问主存、读取操作数，CPU得到操作数在主存中的地址，并从主存中读取该操作数用于运算。部分指令不需要访问主存，则可以跳过该阶段。

结果写回阶段（WB，write back），作为最后一个阶段，结果写回阶段把执行指令阶段的运行结果数据“写回”到某种存储形式。结果数据一般会被写到CPU的内部寄存器中，以便被后续的指令快速地存取；许多指令还会改变程序状态字寄存器中标志位的状态，这些标志位标识着不同的操作结果，可被用来影响程序的动作。

在指令执行完毕、结果数据写回之后，若无意外事件（如结果溢出等）发生，计算机就从程序计数器中取得下一条指令地址，开始新一轮的循环，下一个指令周期将顺序取出下一条指令。



### 关于CPU和程序的执行

1、程序的运行过程，实际上是程序涉及到的、未涉及到的一大堆的指令的执行过程。

当程序要执行的部分被装载到内存后，CPU要从内存中取出指令，然后指令解码(以便知道类型和操作数，简单的理解为CPU要知道这是什么指令)，然后执行该指令。再然后取下一个指令、解码、执行，以此类推直到程序退出。

2、这个取指、解码、执行三个过程构成一个CPU的基本周期。

3、每个CPU都有一套自己可以执行的专门的指令集(注意，这部分指令是CPU提供的，CPU-Z软件可查看)。

正是因为不同CPU架构的指令集不同，使得x86处理器不能执行ARM程序，ARM程序也不能执行x86程序。（Intel和AMD都使用x86指令集，手机绝大多数使用ARM指令集）。

注：指令集的软硬件层次之分：硬件指令集是硬件层次上由CPU自身提供的可执行的指令集合。软件指令集是指语言程序库所提供的指令，只要安装了该语言的程序库，指令就可以执行。

4、由于CPU访问内存以得到指令或数据的时间要比执行指令花费的时间长很多，因此在CPU内部提供了一些用来保存关键变量、临时数据等信息的通用寄存器。

所以，CPU需要提供 一些特定的指令，使得可以从内存中读取数据存入寄存器以及可以将寄存器数据存入内存。

此外还需要提供加法、减、not/and/or等基本运算指令，而乘除法运算都是推算出来的(支持的基本运算指令参见ALU Functions)，所以乘除法的速度要慢的多。这也是算法里在考虑时间复杂度时常常忽略加减法次数带来的影响，而考虑乘除法的次数的原因。

5、除了通用寄存器，还有一些特殊的寄存器。典型的如：

- PC：program counter，表示程序计数器，它保存了将要取出的下一条指令的内存地址，指令取出后，就会更新该寄存器指向下一条指令。
- 堆栈指针：指向内存当前栈的顶端，包含了每个函数执行过程的栈帧，该栈帧中保存了该函数相关的输入参数、局部变量、以及一些没有保存在寄存器中的临时变量。
- PSW：program status word，表示程序状态字，这个寄存器内保存了一些控制位，比如CPU的优先级、CPU的工作模式(用户态还是内核态模式)等。

6、在CPU进行进程切换的时候，需要将寄存器中和当前进程有关的状态数据写入内存对应的位置(内核中该进程的栈空间)保存起来，当切换回该进程时，需要从内存中拷贝回寄存器中。即上下文切换时，需要保护现场和恢复现场。

7、为了改善性能，CPU已经不是单条取指->解码->执行的路线，而是分别为这3个过程分别提供独立的取值单元，解码单元以及执行单元。这样就形成了流水线模式。

例如，流水线的最后一个单元——执行单元正在执行第n条指令，而前一个单元可以对第n+1条指令进行解码，再前一个单元即取指单元可以去读取第n+2条指令。这是三阶段的流水线，还可能会有更长的流水线模式。

8、更优化的CPU架构是superscalar架构（超标量架构）。这种架构将取指、解码、执行单元分开，有大量的执行单元，然后每个取指+解码的部分都以并行的方式运行。比如有2个取指+解码的并行工作线路，每个工作线路都将解码后的指令放入一个缓存缓冲区等待执行单元去取出执行。



![img](https://mmbiz.qpic.cn/mmbiz_png/zYdZKiaLibic66ibkicwv3ZmQgv8icbw9Molhvlv2UnFJYv52s8OHJWzUx52QAvM6Fpicy7vxFOt7tuQ0ibgDdJ1AkyV2Q/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



9、除了嵌入式系统，多数CPU都有两种工作模式：内核态和用户态。这两种工作模式是由PSW寄存器上的一个二进制位来控制的。

10、内核态的CPU，可以执行指令集中的所有指令，并使用硬件的所有功能。

11、用户态的CPU，只允许执行指令集中的部分指令。一般而言，IO相关和把内存保护相关的所有执行在用户态下都是被禁止的，此外其它一些特权指令也是被禁止的，比如用户态下不能将PSW的模式设置控制位设置成内核态。

12、用户态CPU想要执行特权操作，需要发起系统调用来请求内核帮忙完成对应的操作。其实是在发起系统调用后，CPU会执行trap指令陷入(trap)到内核。当特权操作完成后，需要执行一个指令让CPU返回到用户态。

13、除了系统调用会陷入内核，更多的是硬件会引起trap行为陷入内核，使得CPU控制权可以回到操作系统，以便操作系统去决定如何处理硬件异常。

### **关于CPU的基本组成**

1、CPU是用来运算的(加法运算+、乘法运算*、逻辑运算and not or等)，例如c=a+b。

2、运算操作涉及到数据输入(input)、处理、数据输出(output)，a和b是输入数据，加法运算是处理，c是输出数据。

3、CPU需要使用一个叫做存储器(也就是各种寄存器)的东西保存输入和输出数据。以下是几种常见的寄存器(前文也介绍了一些)

- MAR: memory address register，保存将要被访问数据在内存中哪个地址处，保存的是地址值
- MDR: memory data register，保存从内存读取进来的数据或将要写入内存的数据，保存的是数据值
- AC: Accumulator，保存算术运算和逻辑运算的中间结果，保存的是数据值
- PC: Program Counter，保存下一个将要被执行指令的地址，保存的是地址值
- CIR: current instruction register，保存当前正在执行的指令

4、CPU还要将一些常用的基本运算工具(如加法器)放进CPU，这部分负责运算，称为算术逻辑单元(ALU, Arithmetic Logic Unit)。

5、CPU中还有一个控制器(CU, Control Unit)，负责将存储器中的数据送到ALU中去做运算，并将运算后的结果存回到存储器中。

6、控制器之所以知道数据放哪里、做什么运算(比如是做加法还是逻辑运算?)都是由指令告诉控制器的，每个指令对应一个基本操作，比如加法运算对应一个指令。

7、例如，将两个MDR寄存器(保存了来自内存的两个数据)中的值拷贝到ALU中，然后根据指定的操作指令执行加法运算，将运算结果拷贝会一个MDR寄存器中，最后写入到内存。

8、这就是冯诺依曼结构图，也就是现在计算机的结构图。


![img](https://mmbiz.qpic.cn/mmbiz_png/zYdZKiaLibic66ibkicwv3ZmQgv8icbw9MolhvtfYXZicZKkctIswb7O6bBMk5orqS5r7ZRRrVGgs9JicS3QtnxLHZQXyw/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

###  

### **关于CPU的多核和多线程**

1、CPU的物理个数由主板上的插槽数量决定，每个CPU可以有多核心，每核心可能会有多线程。

2、多核CPU的每核(每核都是一个小芯片)，在OS看来都是一个独立的CPU。

3、对于超线程CPU来说，每核CPU可以有多个线程(数量是两个，比如1核双线程，2核4线程，4核8线程)，每个线程都是一个虚拟的逻辑CPU(比如windows下是以逻辑处理器的名称称呼的)，而每个线程在OS看来也是独立的CPU。

这是欺骗操作系统的行为，在物理上仍然只有1核，只不过在超线程CPU的角度上看，它认为它的超线程会加速程序的运行。


![img](https://mmbiz.qpic.cn/mmbiz_png/zYdZKiaLibic66ibkicwv3ZmQgv8icbw9MolhvIeCHBnc68t7GpUPfg8EdJnaq01VE5KeJbGTTdwKwIb5WrmAJ46icmnA/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



4、要发挥超线程优势，需要操作系统对超线程有专门的优化。

5、多线程的CPU在能力上，比非多线程的CPU核心要更强，但每个线程不足以与独立的CPU核心能力相比较。

6、每核上的多线程CPU都共享该核的CPU资源。
例如，假设每核CPU都只有一个"发动机"资源，那么线程1这个虚拟CPU使用了这个"发动机"后，线程2就没法使用，只能等待。

所以，超线程技术的主要目的是为了增加流水线(参见前文对流水线的解释)上更多个独立的指令，这样线程1和线程2在流水线上就尽量不会争抢该核CPU资源。所以，超线程技术利用了superscalar(超标量)架构的优点。

7、多线程意味着每核可以有多个线程的状态。比如某核的线程1空闲，线程2运行。

8、多线程没有提供真正意义上的并行处理，每核CPU在某一时刻仍然只能运行一个进程，因为线程1和线程2是共享某核CPU资源的。可以简单的认为每核CPU在独立执行进程的能力上，有一个资源是唯一的，线程1获取了该资源，线程2就没法获取。

但是，线程1和线程2在很多方面上是可以并行执行的。比如可以并行取指、并行解码、并行执行指令等。所以虽然单核在同一时间只能执行一个进程，但线程1和线程2可以互相帮助，加速进程的执行。

并且，如果线程1在某一时刻获取了该核执行进程的能力，假设此刻该进程发出了IO请求，于是线程1掌握的执行进程的能力，就可以被线程2获取，即切换到线程2。这是在执行线程间的切换，是非常轻量级的。(WIKI: if resources for one process are not available, then another process can continue if its resources are available)

9、多线程可能会出现一种现象：假如2核4线程CPU，有两个进程要被调度，那么只有两个线程会处于运行状态，如果这两个线程是在同一核上，则另一核完全空转，处于浪费状态。更期望的结果是每核上都有一个CPU分别调度这两个进程。



### **关于CPU上的高速缓存**

1、最高速的缓存是CPU的寄存器，它们和CPU的材料相同，最靠近CPU或最接近CPU，访问它们没有时延(<1ns)。但容量很小，小于1kb。

- 32bit：32*32比特=128字节
- 64bit：64*64比特=512字节

2、寄存器之下，是CPU的高速缓存。分为L1缓存、L2缓存、L3缓存，每层速度按数量级递减、容量也越来越大。


![img](https://mmbiz.qpic.cn/mmbiz_png/zYdZKiaLibic66ibkicwv3ZmQgv8icbw9Molhv44RnBBS8dC5brThMrSHicerXZ2MK7aNXgVcXxX3yc2HiaQG2zX26wrYw/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



3、每核心都有一个自己的L1缓存。L1缓存分两种：L1指令缓存(L1-icache)和L1数据缓存(L1-dcache)。L1指令缓存用来存放已解码指令，L1数据缓存用来放访问非常频繁的数据。

4、L2缓存用来存放近期使用过的内存数据。更严格地说，存放的是很可能将来会被CPU使用的数据。

5、多数多核CPU的各核都各自拥有一个L2缓存，但也有多核共享L2缓存的设计。无论如何，L1是各核私有的(但对某核内的多线程是共享的)。